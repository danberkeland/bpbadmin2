// data & functions to calculate the EOD at both north and south locations.
//
// functions here expect orders to be combined and routed like those 
// generated by useT0T7ProdOrders. We expect a flat list of orders that 
// covers T0 and T1. Holding orders are not required but will be filtered
// out anyway.

import { DateTime } from "luxon"
import { useT0T7ProdOrders } from "../../../../data/useT0T7ProdOrders"
import { useListData } from "../../../../data/_listData"
import { useMemo } from "react"
import { keyBy } from "lodash"

import { flow, pickBy, mapValues, mapKeys, groupBy, sumBy } from "lodash/fp"

// maps different croissant type products back to their original shaped type.
// we label orders by these 'shapeNicks' to help us aggregate qtys.

const shapeNickMap = {
  pl: 'pl', frpl: 'pl', al: 'pl', fral: 'pl',
  ch: 'ch', frch: 'ch',
  pg: 'pg', frpg: 'pg',
  sf: 'sf', frsf: 'sf',
  mb: 'mb', frmb: 'mb', unmb: 'mb',
  mini: 'mini', frmni: 'mini',
}
const mapToShapeNick = (prodNick) => shapeNickMap[prodNick]

const isBakedCroix = (product) => product.packGroup === "baked pastries" 
  && product.doughNick === "Croissant"

const makeSummarizedData = (orderArray) => {
  return {
    shapeNick: (orderArray[0] ?? {}).shapeNick,
    total: sumBy('qty')(orderArray),
    items: orderArray,
  }
}

// can take any superset of T0 & T1 orders. Holding orders are not required.
const calculateCroixSentNorth = ({ T0T1Orders, products }) => {

  const shapeNickObject = flow(
    pickBy(isBakedCroix),
    mapValues(product => []),
    mapKeys(mapToShapeNick),
  )(products)  

  const frozenOrders = T0T1Orders
    .filter(order => {
      const product = products[order.prodNick]

      return order.relDate === 0
        && product.packGroup === "frozen pastries"
        && product.doughNick === "Croissant"
        && order.isStand !== false
        && order.routeMeta.route.RouteDepart === "Carlton"

    })
    .map(order => {
      return { ...order, shapeNick: shapeNickMap[order.prodNick] }

    })

  const bakedOrders = T0T1Orders
    .filter(order => {
      const product = products[order.prodNick]

      return order.relDate === 1
        && product.packGroup === "baked pastries"
        && product.doughNick === "Croissant"
        && order.isStand !== false
        && order.routeMeta.route.RouteDepart === "Carlton"

    })
    .map(order => {
      return { ...order, shapeNick: shapeNickMap[order.prodNick] }

    })

  const ordersByShapeNick = {
    ...shapeNickObject,
    ...groupBy('shapeNick')(frozenOrders.concat(bakedOrders))
  }


  return mapValues(makeSummarizedData)(ordersByShapeNick)
  
}




export const useNorthEodData = () => {
  const todayDT = DateTime.now().setZone('America/Los_Angeles').startOf('day')

  const { data:orders } = useT0T7ProdOrders({ 
    shouldFetch: true, 
    reportDate: todayDT.toFormat('yyyy-MM-dd'),
  })
  const { data:PRD } = useListData({ 
    tableName: "Product", 
    shouldFetch: true 
  })



  const calculateValue = () => {
    if (!orders || !PRD) return undefined

    const products = keyBy(PRD, 'prodNick')
    
    console.log(products, orders)
    const croixSentNorth = calculateCroixSentNorth({ 
      T0T1Orders: orders,
      products,
    })

    console.log("croixSentNorth:", croixSentNorth)
  }



  return { data: useMemo(calculateValue, [orders, PRD])}
}




    // PRD.filter(P => {
    //   return P.packGroup === "baked pastries" && P.doughType === "Croissant"
    // })